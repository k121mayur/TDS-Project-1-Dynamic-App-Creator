"""Thin wrapper around the GitHub REST API for repository automation."""

from __future__ import annotations

import base64
from dataclasses import dataclass
from typing import Dict, Iterable, Optional

import httpx

from config import Settings


class GitHubServiceError(RuntimeError):
    """Raised when the GitHub service encounters a fatal error."""


@dataclass(slots=True)
class RepoInfo:
    owner: str
    name: str
    html_url: str
    default_branch: str
    pages_url: Optional[str] = None


class GitHubService:
    """Handle GitHub REST API calls required by the orchestrator."""

    def __init__(self, settings: Settings) -> None:
        if not settings.github_token:
            raise GitHubServiceError("GitHub token not configured.")

        self.settings = settings
        self._client = httpx.Client(
            base_url=settings.github_base_url.rstrip("/"),
            timeout=30.0,
            headers={
                "Authorization": f"token {settings.github_token}",
                "Accept": "application/vnd.github+json",
                "User-Agent": "tds-llm-orchestrator",
            },
        )
        self._login: Optional[str] = None

    def close(self) -> None:
        self._client.close()

    def __enter__(self) -> "GitHubService":
        return self

    def __exit__(self, exc_type, exc, tb) -> None:  # noqa: D401
        self.close()

    @property
    def login(self) -> str:
        if self._login:
            return self._login

        response = self._client.get("/user")
        response.raise_for_status()
        data = response.json()
        self._login = data["login"]
        return self._login

    def _get_owner(self) -> str:
        return self.settings.github_owner or self.login

    def retrieve_repo(self, owner: str, repo_name: str) -> Optional[RepoInfo]:
        response = self._client.get(f"/repos/{owner}/{repo_name}")
        if response.status_code == 404:
            return None
        response.raise_for_status()
        data = response.json()
        pages_url = None
        if pages := data.get("pages"):
            pages_url = pages.get("html_url")
        return RepoInfo(
            owner=data["owner"]["login"],
            name=data["name"],
            html_url=data["html_url"],
            default_branch=data["default_branch"],
            pages_url=pages_url,
        )

    def ensure_repo(
        self,
        repo_name: str,
        description: str,
        homepage: Optional[str] = None,
        topics: Optional[Iterable[str]] = None,
    ) -> RepoInfo:
        owner = self._get_owner()
        existing = self.retrieve_repo(owner, repo_name)
        if existing:
            return existing

        payload = {
            "name": repo_name,
            "description": description[:255],
            "auto_init": False,
            "private": False,
            "has_issues": False,
            "has_projects": False,
            "has_wiki": False,
            "homepage": homepage,
        }
        if topics:
            payload["topics"] = list(topics)

        if owner == self.login:
            response = self._client.post("/user/repos", json=payload)
        else:
            response = self._client.post(f"/orgs/{owner}/repos", json=payload)
        if response.status_code not in {201}:
            raise GitHubServiceError(
                f"Failed to create repository {owner}/{repo_name}: {response.text}",
            )
        data = response.json()
        return RepoInfo(
            owner=data["owner"]["login"],
            name=data["name"],
            html_url=data["html_url"],
            default_branch=data["default_branch"],
        )

    def push_files(
        self,
        repo: RepoInfo,
        files: Dict[str, bytes],
        commit_message: str,
        branch: Optional[str] = None,
    ) -> str:
        """
        Create or update files via the GitHub Contents API.

        Returns the sha of the last commit generated by the upload loop.
        """

        branch_to_use = branch or repo.default_branch or "main"
        last_sha = ""
        for path, content in files.items():
            encoded = base64.b64encode(content).decode("ascii")
            response = self._client.put(
                f"/repos/{repo.owner}/{repo.name}/contents/{path}",
                json={
                    "message": commit_message,
                    "content": encoded,
                    "branch": branch_to_use,
                },
            )
            response.raise_for_status()
            last_sha = response.json()["commit"]["sha"]
        return last_sha

    def ensure_pages_enabled(self, repo: RepoInfo, branch: Optional[str] = None) -> None:
        branch_to_use = branch or repo.default_branch or "main"
        response = self._client.post(
            f"/repos/{repo.owner}/{repo.name}/pages",
            json={
                "build_type": "workflow",
                "source": {"branch": branch_to_use, "path": "/"},
            },
        )
        if response.status_code in {201, 204}:
            return
        if response.status_code == 409:
            return

        response.raise_for_status()

